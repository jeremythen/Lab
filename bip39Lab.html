<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css' rel='stylesheet' integrity='sha512-b2QcS5SsA8tZodcDtGRELiGv5SaKSk1vDHDaQRda0htPYWZ6046lr3kJ5bAAQdpV2mmA/4v0wQF9MyU6/pDIAg==' crossorigin='anonymous'>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-icons/1.11.2/font/bootstrap-icons.min.css" integrity="sha512-D1liES3uvDpPrgk7vXR/hR/sukGn7EtDWEyvpdLsyalQYq6v6YUsTUJmku7B4rcuQ21rf0UTksw2i/2Pdjbd3g==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>

        .monospaced {
            font-family: 'Courier New', Courier, monospace;
        }

        .labels {
            height: 2.5rem;
        }

        .row {
            margin-top: 12px;
        }

        .row p {
            margin: 0;
        }

        #all-words-table-container {
            max-height: 600px;
            overflow-y: auto;
            margin-bottom: 36px;
        }

    </style>

    <title>BIP-39 Lab</title>
</head>
<body>

    <div class="container">
        <h1 class="text-center">BIP-39 Lab</h1>
        <div class="row">
            <div class="col-12">
                <button class="btn btn-outline-primary btn-sm" id="startCollectingEntropyButton" title="Collects entropy on mouse move and key press" onclick="startCollectingEntropy()">Start Collecting mouse and keyboard Entropy</button>
                <button disabled class="btn btn-outline-secondary btn-sm" id="stopCollectingEntropyButton" onclick="stopCollectingEntropy()">Stop Collecting Entropy</button>
                <button class="btn btn-outline-warning btn-sm" id="resetEntropyDataButton" onclick="resetEntropyData()">Reset Entropy Data</button>
            </div>
        </div>
        <div class="row">
            <div class="col-12 mt-2">
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="entropyTypeRadioGroup" id="entropyOf128BitsRadio" checked>
                    <label class="form-check-label" for="entropyOf128Bits">
                        Entropy of 128 bits
                    </label>
                </div>
                <div class="form-check form-check-inline">
                    <input class="form-check-input" type="radio" name="entropyTypeRadioGroup" id="entropyOf256BitsRadio">
                    <label class="form-check-label" for="entropyOf256Bits">
                        Entropy of 256 bits
                    </label>
                </div>
                <button class="btn btn-outline-success btn-sm" id="hashButton" onclick="hashEntropy()">Hash!</button>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>Entropy Data</p>
                <textarea disabled id="entropyDataTextArea" class="form-control" rows="5"></textarea>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p><span class="text-success">Entropy</span> (SHA-256 hash of entropy data)</p>
                <p id="entropyHash" class="form-control labels" disabled></p>
            </div>
        </div>
        <div class="row" id="entropyHash128Container">
            <div class="col-12">
                <p>Using the first 16 bytes (128 bits) of the <span class="text-success">Entropy</span> as the entropy</p>
                <p id="entropyHash128" class="form-control labels" disabled></p>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>SHA-256 hash of <span class="text-success">Entropy</span> to use for getting the checksum<span id="hashForChecksumLabel"></span></p>
                <p id="hashForChecksum" class="form-control labels" disabled></p>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>Checksum <span id="checksumLabel"></span></p>
                <p class="form-control text-primary labels" disabled>
                    <b><span id="checksumTextArea"></span></b>
                </p>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p><span class="text-success">Entropy</span> with checksum hex appended at the end</span></p>
                <p id="entropyHashWithChecksum" class="form-control labels" disabled></p>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p><span class="text-success">Entropy</span> with checksum in binary split by 11 bits</p>
                <textarea type="text" id="entropyHashWithChecksumInBinaryTextArea" class="form-control" rows="3" disabled></textarea>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>Seed phrase</p>
                <textarea disabled id="seedPhraseTextArea" class="form-control" rows="2"></textarea>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>Seed phrase table</p>
                <div id="table-container"></div>
            </div>
        </div>
        <div class="row">
            <div class="col-12">
                <p>BIP39 words: <a target="_blank" href="https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt">https://github.com/bitcoin/bips/blob/master/bip-0039/english.txt</a></p>
                <p>All BIP39 words</p>
                <div id="all-words-table-container"></div>
            </div>
        </div>
    </div>

<script>

    const ALGORITHMS = {
        SHA256: 'SHA-256',
        SHA512: 'SHA-512',
    };

    const bip39Words = [];

    async function hash(message, algorithm = ALGORITHMS.SHA256) {
        const msgBuffer = new TextEncoder().encode(message);                    
        const hashBuffer = await crypto.subtle.digest(algorithm, msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));             
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        return hashHex;
    };

    function onEntropyTypeRadioGroupChange (event) {
        const entropyOf128Bits = entropyOf128BitsRadio.checked;
        const entropyOf256Bits = entropyOf256BitsRadio.checked;
        if(entropyOf128Bits) {
            showContainer('entropyHash128Container');
        } else if(entropyOf256Bits) {
            hideContainer('entropyHash128Container');
        }
        
        if(entropyDataTextArea.value.trim() !== '') {
            hashEntropy();
        }
    }

    document.querySelectorAll("input[name='entropyTypeRadioGroup']").forEach((input) => {
        input.addEventListener('change', onEntropyTypeRadioGroupChange);
    });

    function showContainer(id) {
        document.getElementById(id).classList.remove('d-none');
    }

    function hideContainer(id) {
        document.getElementById(id).classList.add('d-none');
    }

    async function hashEntropy() {

        const useEntropyOf128Bits = entropyOf128BitsRadio.checked;
        const checksumHexLength = useEntropyOf128Bits ? 1 : 2;
        
        const entropyDataString = entropyData.join('');
        let entropyDataHash = await hash(entropyDataString);

        entropyHash.innerText = entropyDataHash;

        if(useEntropyOf128Bits) {
            const entropyOf128Bits = entropyDataHash.slice(0, 32);
            entropyHash128.innerText = entropyOf128Bits;
            entropyDataHash = entropyOf128Bits;
        }

        const entropyDataHashInBinary = BigInt('0x' + entropyDataHash).toString(2).padStart(256, '0');

        const hashOfEntropy = await hash(entropyDataHash);

        const checksumBits = hashOfEntropy.slice(0, checksumHexLength);

        hashForChecksum.innerHTML = `<b><span class="text-primary">${checksumBits}</span></b>` + hashOfEntropy.slice(checksumHexLength);
        hashForChecksumLabel.innerText = ` (sha256(${entropyDataHash}))`;

        checksumTextArea.innerText = checksumBits;
        checksumLabel.innerText = ` (first ${checksumHexLength} character${useEntropyOf128Bits && 's'} of the hash for checksum)`;

        entropyHashWithChecksum.innerHTML = entropyDataHash + `<b><span class="text-primary">${checksumBits}</span></b>`;

        const bitLength = useEntropyOf128Bits ? 128 : 256;

        const entropyWithChecksum = entropyDataHash + checksumBits;

        const checksumSplitIn11Bits = BigInt('0x' + entropyWithChecksum)
            .toString(2)
            .padStart(bitLength, '0')
            .match(/.{1,11}/g);

        entropyHashWithChecksumInBinaryTextArea.value = checksumSplitIn11Bits.join(' ');

        const seedPhrases = checksumSplitIn11Bits
            .map(binary => bip39Words[parseInt(binary, 2)]);

        seedPhraseTextArea.value = seedPhrases.join(' ');

        createHexTable(entropyWithChecksum);

        createAllWordsTable(seedPhrases);

    }

    async function fetchBip39WordListAndVerifyingIntegrity() {

        const bit39WordListSha512IntegrityHash = '416c71ba30018ea292bb36cdc23c9329673485a8d8933266a9d9a7cc72153b8baed3d430f52eab4f5d3addf6583611b3777a50454599f1e42716f5f879621123';

        const bip39WordListUrl = 'https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt';

        const response = await fetch(bip39WordListUrl);

        if (!response.ok) {
            throw new Error(`Failed to fetch resource. Status: ${response.status}`);
        }

        const bip39WordListResponseText = await response.text();

        const actualHash = await hash(bip39WordListResponseText, ALGORITHMS.SHA512);

        if (actualHash !== bit39WordListSha512IntegrityHash) {
            throw new Error('Resource integrity verification failed.');
        }

        const bip39Words = bip39WordListResponseText.split('\n').filter(word => word.trim() !== '');

        return bip39Words;

    };

    const entropyData = [];

    function handleMouseMove(event) {
        const mouseData = `${event.clientX}${event.clientY}`;
        appendToEntropy(mouseData);
    }

    function handleKeyPress(event) {
        const keyData = `${event.charCode}${event.keyCode}`;
        appendToEntropy(keyData);
    }

    function appendToEntropy(data) {
        entropyData.push(data);
        entropyDataTextArea.value = entropyData.join('');
    }

    function startCollectingEntropy () {
        entropyData.length = 0;
        document.body.addEventListener('mousemove', handleMouseMove);
        document.body.addEventListener('keypress', handleKeyPress);
        startCollectingEntropyButton.disabled = true;
        stopCollectingEntropyButton.disabled = false;
        resetEntropyDataButton.disabled = true;
        hashButton.disabled = true;
        resetEntropyData();
    }

    function stopCollectingEntropy() {
        document.body.removeEventListener('mousemove', handleMouseMove);
        document.body.removeEventListener('keypress', handleKeyPress);
        startCollectingEntropyButton.disabled = false;
        stopCollectingEntropyButton.disabled = true;
        resetEntropyDataButton.disabled = false;
        hashButton.disabled = false;
    }

    function hash128EntropyData() {
        const entropyDataString = entropyData.join('');
        const entropyDataHash = hash(entropyDataString, ALGORITHMS.SHA128);
    }

    function hash556EntropyData() {
        const entropyDataString = entropyData.join('');
        const entropyDataHash = hash(entropyDataString, ALGORITHMS.SHA256);
    }

    function resetEntropyData() {
        entropyData.length = 0;
        entropyData.value = '';
        entropyHash.innerText = '';
        entropyHash128.innerText = '';
        hashForChecksum.innerText = '';
        checksumTextArea.value = '';
        entropyHashWithChecksum.innerHTML = '';
        entropyHashWithChecksumInBinaryTextArea.value = '';
        seedPhraseTextArea.value = '';
        entropyDataTextArea.value = '';
        checksumLabel.innerText = '';
        checksumTextArea.innerText = '';
        hashForChecksumLabel.innerText = '';
        clearSeedPhraseTable();
        clearWordListTable();
        createAllWordsTable();
    }

    function clearSeedPhraseTable() {
        const tableContainer = document.getElementById('table-container');
        tableContainer.innerHTML = '';
    }

    function clearWordListTable() {
        const tableContainer = document.getElementById('all-words-table-container');
        tableContainer.innerHTML = '';
    }

    function createHexTable(hexString) {

        const binaryLength = hexString.length * 4;

        const binaryStr = BigInt('0x' + hexString).toString(2).padStart(binaryLength, '0');

        const binaryStrSplittedBy11Bits = binaryStr.match(/.{1,11}/g) || [];

        const table = document.createElement('table');
        table.classList.add('table', 'table-bordered');

        const thead = document.createElement('thead');
        thead.innerHTML = `
            <tr>
                <th scope="col">Word Index In Binary</th>
                <th scope="col">Word Index In Decimal</th>
                <th scope="col">Word</th>
            </tr>
        `;
        table.appendChild(thead);

        const tbody = document.createElement('tbody');

        binaryStrSplittedBy11Bits.forEach((binary, index) => {

            const wordIndex = parseInt(binary, 2);

            const row = document.createElement('tr');

            if(index === binaryStrSplittedBy11Bits.length - 1) {
                binary = `<b>${binary}</b> (checksum)`;
            }

            const word = bip39Words[wordIndex];

            row.innerHTML = `
                <td class="monospaced">${binary}</td>
                <td>${wordIndex}</td>
                <td>${word}</td>
            `;

            tbody.appendChild(row);
        });

        table.appendChild(tbody);

        const tableContainer = document.getElementById('table-container');
        tableContainer.innerHTML = '';

        tableContainer.appendChild(table);

  }

    function createAllWordsTable(seedPhrases = []) {

        const seedPhrasesMap = seedPhrases.reduce((acc, word) => {
            acc[word] = true;
            return acc;
        }, {});
    
        const table = document.createElement('table');
        table.classList.add('table', 'table-bordered');
    
        const thead = document.createElement('thead');
        thead.innerHTML = `
            <tr>
                <th scope="col">Word Index</th>
                <th scope="col">Word</th>
            </tr>
        `;
        table.appendChild(thead);
    
        const tbody = document.createElement('tbody');
    
        bip39Words.forEach((word, index) => {
    
            const row = document.createElement('tr');

            if(seedPhrasesMap[word]) {
                row.classList.add('table-success');
            }
    
            row.innerHTML = `
                <td>${index}</td>
                <td>${word}</td>
            `;
    
            tbody.appendChild(row);
        });
    
        table.appendChild(tbody);
    
        const tableContainer = document.getElementById('all-words-table-container');
        tableContainer.innerHTML = '';
    
        tableContainer.appendChild(table);
    
    }

  fetchBip39WordListAndVerifyingIntegrity()
    .then((words) => {
        bip39Words.push(...words);
        createAllWordsTable();
    })
    .catch((error) => {
        console.error("error: ", error);
        alert('Failed to fetch BIP39 words. Please check the console for more details.');
    });

</script>
    
</body>
</html>